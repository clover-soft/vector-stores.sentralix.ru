### Шаг 13: Отложенная индексация (полный цикл)
- Цель: 
  - Реализовать полный цикл индексации через провайдера: создание индекса, получение `external_id`, загрузка/прикрепление файлов, запуск индексации, проверка статуса, синхронизация статуса в БД, удаление индекса у провайдера.
- Действия: 
  - Используемые переменные окружения:
    - `DATABASE_URI` — строка подключения к MariaDB (SQLAlchemy). Используется для чтения/обновления `rag_indexes`, `rag_index_files`, фиксации статусов индексации.
    - `YC_FOLDER_ID` — идентификатор каталога Yandex Cloud (для провайдера `yandex`).
    - `YC_SA_KEY_JSON_B64` — base64-строка с JSON ключом сервисного аккаунта Yandex Cloud (для провайдера `yandex`).
  - Реализовать сервис оркестрации индексации (pipeline), который выполняет:
    - создание пустого индекса у провайдера;
    - сохранение `rag_indexes.external_id`;
    - добавление файлов “на лету” по одному:
      - обеспечить загрузку файла в провайдера (Files API / `rag_provider_file_uploads.get_or_sync`)
      - прикрепить файл к индексу у провайдера (Vector Stores Files API, attach)
      - при прикреплении передавать `chunking_strategy` из `rag_files.chunking_strategy` (на уровне файла)
      - не ждать завершения индексации
    - опрос (polling) статуса:
      - по файлам в индексе (`list_vector_store_files` / `retrieve_vector_store_file`)
      - агрегирование статуса индекса в `rag_indexes.indexing_status` на основе статусов файлов
    - синхронизация `metadata.provider_payload` (payload индекса) и дат в БД.
  - Важно:
    - явного “запуска индексации” отдельной командой может не быть; индексация начинается на стороне провайдера автоматически после attach.
    - pipeline не блокирует запросы и не делает долгих ожиданий — только ставит операции в провайдер и затем периодически поллит статусы.
  - Реализовать операции удаления индекса у провайдера при удалении локального индекса (или по отдельной команде API).
  - Реализовать API ручки для:
    - создания пустого внешнего индекса по локальному `index_id` (если `external_id` отсутствует);
    - добавления (attach) одного локального файла в индекс без ожидания индексации;
    - получения текущего статуса индексации:
      - по индексу (агрегированный `indexing_status`)
      - по файлам индекса (статусы vector store files).
  - Обеспечить идемпотентность:
    - повторный запуск не должен приводить к повреждению состояния;
    - если `external_id` уже есть — не создавать индекс повторно без явного запроса.
  - Обеспечить доменную изоляцию во всех этапах.
- Ожидаемый результат: 
  - Внешний бэкенд может запустить индексацию и наблюдать статус, а сервис синхронизирует состояния с провайдером.
- Критерии готовности (Definition of Done):  
  - `external_id` создаётся и сохраняется в `rag_indexes`.
  - `indexing_status` корректно переходит по стадиям (`not_indexed` → `in_progress` → `done/failed`).
  - Ошибки провайдера приводят к `failed` и записываются в логи.
  - Удаление локального индекса корректно удаляет индекс у провайдера (при наличии `external_id`).
  - Swagger документирован (описания, схемы ошибок, коды ответов).
- Выполнено: нет
